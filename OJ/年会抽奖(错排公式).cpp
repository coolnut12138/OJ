链接：https://www.nowcoder.com/questionTerminal/610e6c0387a0401fb96675f58cda8559?toCommentId=25418
来源：牛客网

今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：
1. 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；
2. 待所有字条加入完毕，每人从箱中取一个字条；
3. 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？

输入描述 :
输入包含多组数据，每组数据包含一个正整数n（2≤n≤20）。


输出描述 :
对应每一组数据，以“xx.xx%”的格式输出发生无人获奖的概率。

//////////////////////////////////////////////////////////////////////////////////////////////////
//思路：
无人获奖的概率，就是用 (无人获奖有几种抽法) 除以 (抽奖总次数)
分母：抽奖总次数：以 5 举例子：第一个人有 5 种抽法，第二个人就有 4 种抽法 。。。。
	则总共有5*4*3*2*1种抽法，即5！，那么 n 种就有n！种抽法

分子：无人获奖有几种抽法(错排公式)：设 n 个人有F(n)种抽法
	比如有 n 个人，第一个人(1号)不能抽自己，则有 n-1 种抽法，假设第一个人抽了3号
	第二个人（3号人）就有两种情况了：① 抽1号的名字：如果 3 号抽了 1 号的名字，那么剩下的 n - 2 个人就
									还是从 n - 2 个名字中抽，即 F(n - 2) 种，算上第一个人的抽的次数，
									则共(n - 1)*F(n - 2)种
								  ②不抽1号的名字：如果 3 号不抽 1 号的名字，那么算上 3 号剩下的就
								  有 n - 1 个人，则共 F(n - 1) 种抽法，算上第一个人抽的次数
								  共(n - 1)*F(n - 1)种

得通式：n个人不获奖有(n - 1)*F(n - 1) + (n - 1)*F(n - 2) = (n - 1)*(F(n - 1) + F(n - 2))种抽法
#include <iostream>
using namespace std;

int main()
{
	long long probility[21][2] = { { 0, 1 }, { 0, 1 }, { 1, 2 } };
	for (int i = 3; i <= 21; i++){
		probility[i][0] = (i - 1)*(probility[i - 1][0] + probility[i - 2][0]);    //分子：有多少种情况无人获奖
		probility[i][1] = i * probility[i - 1][1];    //分母：一共有多少种抽法：n!种
	}
	int n;
	while (cin >> n){
		double ret = (double)probility[n][0] / probility[n][1] * 100;
		cout.precision(2);		//控制输出精度为小数点后两位
		cout << fixed << ret << "%" << endl;	//fixed是输出精度不够时补0
	}
	return 0;
}